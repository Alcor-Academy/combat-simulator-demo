{
  "task_id": "02-03",
  "phase": 2,
  "step": 3,
  "name": "Implement CombatRound Domain Service",
  "driven_by_scenario": "E2E Scenarios 3 (attacker kills defender), 4 (defender survives and counter-attacks)",
  "description": "Orchestrate one combat round with attacker advantage rule: attacker attacks first, defender counter-attacks ONLY if alive after attacker's strike. Returns RoundResult with complete round details.",
  "motivation": "Implements attacker advantage - critical business rule that dead defender cannot counter-attack. Orchestrates AttackResolver for both strikes in proper sequence.",
  "estimated_hours": 0.75,
  "estimated_minutes": 45,
  "dependencies": ["02-02"],
  "result_dataclass_required": {
    "name": "RoundResult",
    "location": "modules/domain/model/round_result.py",
    "purpose": "Immutable value object containing complete combat round results",
    "create_first": true,
    "fields": [
      {"name": "round_number", "type": "int"},
      {"name": "attacker_action", "type": "AttackResult", "description": "Attacker's strike details"},
      {"name": "defender_action", "type": "AttackResult | None", "description": "Counter-attack details, None if defender died"},
      {"name": "attacker_hp_before", "type": "int"},
      {"name": "attacker_hp_after", "type": "int"},
      {"name": "defender_hp_before", "type": "int"},
      {"name": "defender_hp_after", "type": "int"},
      {"name": "combat_ended", "type": "bool", "description": "True if one character died this round"},
      {"name": "winner", "type": "Character | None", "description": "Victor if combat ended, None otherwise"}
    ],
    "immutability": "@dataclass(frozen=True)"
  },
  "acceptance_criteria": [
    "RoundResult value object in modules/domain/model/round_result.py (@dataclass(frozen=True) with 9 fields)",
    "CombatRound service in modules/domain/services/combat_round.py",
    "execute_round(attacker, defender, round_number) returns RoundResult",
    "Attacker attacks first using AttackResolver",
    "Defender counter-attacks ONLY if is_alive after attacker's strike",
    "If defender dies, defender_action = None (no counter-attack)",
    "RoundResult includes all 9 fields with complete round state",
    "4-6 unit tests PASS",
    "E2E Scenarios 3, 4 PASS (was SKIP)"
  ],
  "instructions": {
    "outer_loop_e2e": ["Run: pytest tests/e2e/ -v", "OBSERVE: Scenarios 3, 4 SKIP (CombatRound import fails)", "IDENTIFY: Need RoundResult + CombatRound with conditional counter-attack logic"],
    "result_dataclass_creation": ["Create modules/domain/model/round_result.py", "Import: from dataclasses import dataclass, from typing import Optional", "from modules.domain.model.character import Character", "from modules.domain.model.attack_result import AttackResult", "@dataclass(frozen=True)", "class RoundResult:", "    round_number: int", "    attacker_action: AttackResult", "    defender_action: Optional[AttackResult]", "    attacker_hp_before: int", "    attacker_hp_after: int", "    defender_hp_before: int", "    defender_hp_after: int", "    combat_ended: bool", "    winner: Optional[Character]"],
    "inner_loop_unit": {
      "tdd_cycles": [
        {
          "cycle": 1,
          "feature": "Attacker attacks first",
          "red": ["Create tests/unit/domain/services/test_combat_round.py", "Write test_attacker_attacks_first() using mocked AttackResolver", "Verify attacker_action is AttackResult from attacker's strike", "Run: pytest → ImportError (RED)"],
          "green": ["Create modules/domain/services/combat_round.py", "class CombatRound:", "    def __init__(self, attack_resolver: AttackResolver):", "        self._attack_resolver = attack_resolver", "    def execute_round(self, attacker: Character, defender: Character, round_number: int) -> RoundResult:", "        attacker_hp_before = attacker.hp", "        defender_hp_before = defender.hp", "        ", "        # Attacker strikes first", "        attacker_attack = self._attack_resolver.resolve_attack(attacker, defender)", "        defender_after_first_strike = attacker_attack.defender_after", "        ", "        # Placeholder: assume no counter-attack for now", "        return RoundResult(", "            round_number=round_number,", "            attacker_action=attacker_attack,", "            defender_action=None,", "            attacker_hp_before=attacker_hp_before,", "            attacker_hp_after=attacker.hp,", "            defender_hp_before=defender_hp_before,", "            defender_hp_after=defender_after_first_strike.hp,", "            combat_ended=not defender_after_first_strike.is_alive,", "            winner=attacker if not defender_after_first_strike.is_alive else None", "        )", "Run: pytest → 1 test PASSED (GREEN)"]
        },
        {
          "cycle": 2,
          "feature": "Defender counter-attacks if alive",
          "red": ["Write test_defender_counter_attacks_if_alive():", "    Attacker deals non-lethal damage (defender survives with HP > 0)", "    Verify defender_action is AttackResult from defender's counter-attack", "    Verify attacker HP reduced by counter-attack", "Run: pytest → Test FAILED (defender_action always None, RED)"],
          "green": ["Modify execute_round to add conditional counter-attack:", "        # Defender counter-attacks if alive", "        if defender_after_first_strike.is_alive:", "            defender_attack = self._attack_resolver.resolve_attack(", "                defender_after_first_strike, attacker", "            )", "            attacker_after_counter = defender_attack.defender_after", "            return RoundResult(", "                round_number=round_number,", "                attacker_action=attacker_attack,", "                defender_action=defender_attack,", "                attacker_hp_before=attacker_hp_before,", "                attacker_hp_after=attacker_after_counter.hp,", "                defender_hp_before=defender_hp_before,", "                defender_hp_after=defender_after_first_strike.hp,", "                combat_ended=not attacker_after_counter.is_alive,", "                winner=defender_after_first_strike if not attacker_after_counter.is_alive else None", "            )", "        else:", "            # Defender dead, no counter-attack", "            return RoundResult(", "                round_number=round_number,", "                attacker_action=attacker_attack,", "                defender_action=None,", "                attacker_hp_before=attacker_hp_before,", "                attacker_hp_after=attacker.hp,", "                defender_hp_before=defender_hp_before,", "                defender_hp_after=defender_after_first_strike.hp,", "                combat_ended=True,", "                winner=attacker", "            )", "Run: pytest → 2 tests PASSED (GREEN)"]
        },
        {
          "cycle": 3,
          "feature": "Defender no counter-attack if dead",
          "red_green": ["Write test_defender_no_counter_attack_if_dead():", "    Attacker deals lethal damage (defender HP → 0)", "    Verify defender_action is None", "    Verify attacker HP unchanged (no counter-attack)", "Should PASS immediately if conditional logic correct"]
        },
        {
          "cycle": 4,
          "feature": "Round result field completeness",
          "red_green": ["Write test_round_result_includes_all_details() - verifies all 9 fields", "Should PASS if implementation complete"]
        }
      ],
      "refactoring": {
        "scope": "Level 1-2 only (extract methods/constants, compose method). Defer Level 3+ (responsibility org, class extraction) to post-round cleanup.",
        "when_to_refactor": "ONLY after tests are GREEN. Extract if method becomes difficult to understand OR exceeds 30 lines (readability takes precedence over line count).",
        "level_guidance": {
          "level_1": "Foundation (extract constants, remove comments) - Not needed here",
          "level_2": "Complexity reduction (extract _execute_attacker_strike and _execute_counter_attack helpers) - Apply if execute_round clarity degrades",
          "level_3_and_above": "Defer to post-round cleanup (responsibility organization, class extraction not needed for single service)"
        },
        "what_if_you_accidentally_refactor_during_red": {
          "step_1": "STOP immediately when you realize tests broke due to refactoring",
          "step_2": "Run: git status (see what files changed during refactoring attempt)",
          "step_3": "Run: git diff (review the refactoring changes that broke tests)",
          "step_4": "Run: git checkout -- <files> (revert ALL refactoring changes back to RED state)",
          "step_5": "Return to making tests GREEN with original (unrefactored) code structure",
          "step_6": "ONLY AFTER all tests pass GREEN, redo refactoring properly with working tests",
          "step_7": "Run tests again to verify GREEN maintained after refactoring"
        }
      }
    },
    "return_to_e2e": ["Run: pytest tests/e2e/ -v", "OBSERVE: Scenarios 3, 4 now PASSED", "TOTAL: 8 scenarios PASSED (2, 3, 4, 5, 6, 7, 8, 9)"]
  },
  "verification": {
    "unit_tests": ["pytest tests/unit/domain/services/test_combat_round.py -v → 4-6 tests PASSED"],
    "e2e_tests": ["pytest tests/e2e/ -v → Scenarios 3, 4 PASSED"],
    "implementation_checks": ["Attacker advantage enforced (no counter-attack if defender dies)", "RoundResult.defender_action is None when defender killed", "Both characters' HP tracked before and after round"]
  },
  "e2e_scenarios_affected": ["3", "4"],
  "scenarios_passing_after": ["3", "4"],
  "cross_step_impacts": ["03-01: CombatSimulator uses RoundResult dataclass as primary input (tuple[RoundResult, ...])"],
  "commit_message": "feat(domain): Implement CombatRound service with attacker advantage\n\nOutside-In TDD (Unit → E2E validation):\n- RoundResult value object (9 fields, frozen dataclass)\n- CombatRound orchestrates one combat round\n- Attacker attacks first (AttackResolver)\n- Defender counter-attacks ONLY if alive after attacker's strike\n- Attacker advantage: dead defender cannot counter-attack\n- Returns RoundResult with complete round details\n\nImplementation:\n- Constructor injection: CombatRound(attack_resolver: AttackResolver)\n- CRITICAL: Check defender.is_alive BEFORE counter-attack\n- Conditional logic: if defender_after.is_alive → counter-attack, else → None\n- combat_ended and winner determined by final state\n\nTests: 4-6 unit tests PASSED\nE2E: Scenarios 3, 4 now PASS (was SKIP)\n\nDriven by:\n- Scenario 3: Attacker kills defender - no counter-attack occurs\n- Scenario 4: Defender survives and counter-attacks\n\nCo-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>",
  "reviews": [
    {
      "reviewer": "software-crafter-reviewer",
      "date": "2026-01-09T00:00:00Z",
      "ready_for_execution": true,
      "approval_status": "APPROVED",
      "dimensions_reviewed": {
        "dimension_1_outside_in_atdd": {
          "status": "PASS",
          "evidence": "driven_by_scenario explicitly references E2E Scenarios 3 & 4; clear outer-loop → inner-loop traceability; E2E expectations drive unit test design"
        },
        "dimension_2_test_first_discipline": {
          "status": "PASS",
          "evidence": "Tests written before implementation code; RED→GREEN→REFACTOR explicit in each cycle; Python TDD semantics correct (ImportError as RED phase)"
        },
        "dimension_3_self_containment_atomicity": {
          "status": "PASS",
          "evidence": "All necessary details included; no forward references; single responsibility (CombatRound with conditional counter-attack logic); executable without reading prior steps"
        },
        "dimension_4_result_dataclass": {
          "status": "PASS",
          "evidence": "Complete 9-field specification with precise types (Optional[AttackResult], Optional[Character]); @dataclass(frozen=True) enforced; create_first: true ordering correct"
        },
        "dimension_5_refactoring_strategy": {
          "status": "NEEDS_ENHANCEMENT",
          "evidence": "States Level 2 extraction example (30 lines), but missing: (A) 7-step recovery procedure if refactoring during RED, (B) progressive level guidance (which levels apply here vs. defer), (C) readability vs. line-count heuristic"
        },
        "dimension_6_solid_hexagonal": {
          "status": "PASS",
          "evidence": "Dependency direction correct (AttackResolver via constructor injection); protocol-based abstractions used; immutable value objects (frozen dataclass); domain logic isolated from infrastructure"
        },
        "dimension_7_acceptance_criteria": {
          "status": "PASS",
          "evidence": "All 9 criteria specific and measurable; testable with pytest commands; covers success (defender survives) and edge cases (defender dies); includes implementation checks"
        }
      },
      "critiques": [
        {
          "severity": "MEDIUM",
          "category": "Refactoring Strategy",
          "issue": "Missing 7-step recovery procedure for RED-phase refactoring",
          "location": "instructions.inner_loop_unit.refactoring",
          "details": "Current refactoring section shows extraction target (_execute_attacker_strike) but lacks guidance on what to do if developer refactors during RED phase before GREEN is achieved.",
          "recommendation": "Add explicit recovery procedure: (1) Recognize refactoring broke RED test, (2) Undo refactoring immediately, (3) Return to original RED state, (4) Complete GREEN phase with original structure, (5) THEN refactor only after GREEN, (6) Verify tests still pass after refactoring, (7) Commit refactoring separately."
        },
        {
          "severity": "MEDIUM",
          "category": "Refactoring Strategy",
          "issue": "No progressive refactoring level guidance",
          "location": "instructions.inner_loop_unit.refactoring",
          "details": "Refactoring section shows Level 2 example but doesn't contextualize it within the 6-level progressive hierarchy. Unclear whether developer should extract immediately or defer.",
          "recommendation": "Add: 'Apply Level 1-2 refactoring only (extraction, method composition). Defer Level 3+ (responsibility organization, class extraction) to post-round cleanup. Stop if tests passing and method clarity adequate.'"
        },
        {
          "severity": "LOW",
          "category": "Refactoring Strategy",
          "issue": "Line-count heuristic used without readability context",
          "location": "instructions.inner_loop_unit.refactoring (level_2)",
          "details": "Trigger stated as '30 lines' but readability should take precedence over line count.",
          "recommendation": "Reframe as: 'Extract if method becomes difficult to understand OR exceeds 30 lines (whichever comes first). Prioritize readability and single-responsibility over arbitrary line count.'"
        }
      ],
      "strengths": [
        "Excellent outside-in ATDD discipline with explicit E2E→unit test traceability",
        "Comprehensive result dataclass specification with all 9 fields precisely typed and immutable",
        "Clear TDD cycle sequencing with expected RED→GREEN states documented",
        "Strong business logic capture (attacker advantage rule explicitly verified)",
        "Self-contained and executable without external context",
        "Hexagonal architecture correctly applied (constructor injection, protocol-based dependencies)"
      ],
      "summary": "This step demonstrates professional-grade Outside-In TDD implementation. All critical dimensions pass: ATDD integrity, test-first discipline, self-containment, dataclass design, SOLID principles, and acceptance criteria quality. Minor enhancements to refactoring guidance would strengthen future execution, but these do not block proceeding. Developer has all necessary information to complete CombatRound service with full test coverage."
    }
  ]
}
