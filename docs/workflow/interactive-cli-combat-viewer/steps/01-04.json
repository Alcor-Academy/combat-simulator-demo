{
  "task_id": "01-04",
  "project_id": "interactive-cli-combat-viewer",
  "execution_agent": "software-crafter",
  "self_contained_context": {
    "background": "Part of Phase 1: Baseline - Minimum Viable CLI. CombatRenderer is the heart of combat visualization. Plain text implementation proves\nrendering logic works before adding visual complexity (emoji, colors). Testable in isolation.\n",
    "prerequisites_completed": [
      "01-03"
    ],
    "relevant_files": [
      "modules/infrastructure/cli/combat_renderer.py (create)",
      "tests/unit/infrastructure/cli/test_combat_renderer.py (create)"
    ],
    "technical_context": "Create CombatRenderer for formatting combat output (no colors/emoji yet).\n\nFile: modules/infrastructure/cli/combat_renderer.py\n\nImplementation:\n```python\nfrom modules.domain.model.combat_result import CombatResult\nfrom modules.infrastructure.cli.console_output import ConsoleOutput\nfrom modules.infrastructure.cli.config import CLIConfig\n\nclass CombatRenderer:\n    \"\"\"Formats combat events for display.\"\"\"\n\n    def __init__(self, console: ConsoleOutput, config: CLIConfig):\n        self._console = console\n        self._config = config\n\n    def render_combat(self, result: CombatResult) -> None:\n        \"\"\"Render complete combat (plain text for baseline).\"\"\"\n        self._render_initiative(result.initiative_result)\n\n        for round_result in result.rounds:\n            self._render_round(round_result)\n\n        self._render_victory(result)\n\n    def _render_initiative(self, init_result) -> None:\n        \"\"\"Display initiative resolution.\"\"\"\n        self._console.print(\"Rolling Initiative...\")\n        self._console.print(f\"{init_result.attacker.name}: {init_result.attacker_total}\")\n        self._console.print(f\"{init_result.defender.name}: {init_result.defender_total}\")\n        self._console.print(f\"{init_result.attacker.name} attacks first!\")\n        self._console.display_with_delay(\"\", self._config.initiative_winner_delay)\n\n    def _render_round(self, round_result) -> None:\n        \"\"\"Display single combat round.\"\"\"\n        self._console.print(f\"\\n=== ROUND {round_result.round_number} ===\")\n        self._console.display_with_delay(\"\", self._config.round_header_delay)\n\n        # Attacker action\n        action = round_result.attacker_action\n        self._console.print(f\"{action.attacker_name} attacks!\")\n        self._console.print(f\"  Damage: {action.total_damage}\")\n        self._console.print(f\"  {action.defender_name}: {action.defender_old_hp} HP -> {action.defender_new_hp} HP\")\n        self._console.display_with_delay(\"\", self._config.attack_delay)\n\n        # Defender counter-attack (if alive)\n        if round_result.defender_action:\n            action = round_result.defender_action\n            self._console.print(f\"{action.attacker_name} counter-attacks!\")\n            self._console.print(f\"  Damage: {action.total_damage}\")\n            self._console.print(f\"  {action.defender_name}: {action.defender_old_hp} HP -> {action.defender_new_hp} HP\")\n            self._console.display_with_delay(\"\", self._config.attack_delay)\n        else:\n            self._console.print(f\"{round_result.attacker_action.defender_name} has been defeated!\")\n            self._console.display_with_delay(\"\", self._config.death_delay)\n\n    def _render_victory(self, result: CombatResult) -> None:\n        \"\"\"Display victory announcement.\"\"\"\n        self._console.print(f\"\\n=== {result.winner.name.upper()} WINS! ===\")\n        self._console.print(f\"Combat lasted {result.total_rounds} rounds\")\n        self._console.print(f\"{result.winner.name}: {result.winner.hp} HP remaining\")\n        self._console.print(f\"{result.loser.name}: 0 HP (defeated)\")\n        self._console.prompt_continue(\"\\nPress ENTER to exit...\")\n```\n\nUnit tests:\n- File: tests/unit/infrastructure/cli/test_combat_renderer.py\n- Test: test_render_initiative_displays_rolls()\n- Test: test_render_round_displays_attacker_action()\n- Test: test_render_round_displays_counter_if_alive()\n- Test: test_render_round_no_counter_if_defender_dead()\n- Test: test_render_victory_displays_winner()\n\nTest pattern (using test_mode for zero delays):\n```python\ndef test_render_initiative_displays_rolls():\n    mock_console = Mock(spec=ConsoleOutput)\n    config = CLIConfig.test_mode()\n    renderer = CombatRenderer(mock_console, config)\n\n    # Create InitiativeResult with known values\n    char1 = Character(\"Hero\", 50, 10)\n    char2 = Character(\"Villain\", 40, 8)\n    init_result = InitiativeResult(\n        attacker=char1, defender=char2,\n        attacker_roll=5, defender_roll=3,\n        attacker_total=65, defender_total=51\n    )\n\n    renderer._render_initiative(init_result)\n\n    # Verify output contains expected text\n    calls = [str(call) for call in mock_console.print.call_args_list]\n    assert any(\"Hero\" in str(call) for call in calls)\n    assert any(\"attacks first\" in str(call) for call in calls)\n\n    # PHASE 3: After emoji implementation, add emoji/fallback verification\n    # Example: assert any('\u2694\ufe0f' in str(call) or '[ATK]' in str(call) for call in calls)\n    # This validates emoji integration end-to-end (emoji OR fallback present)\n```\n\nValidation:\n- pytest tests/unit/infrastructure/cli/test_combat_renderer.py -v\n- All unit tests PASS (5 tests minimum)\n- Code coverage > 85%\n",
    "tdd_phase": "GREEN",
    "active_e2e_test": "E2E Test 1.1 (Baseline Combat) - should PASS when complete",
    "inactive_e2e_tests": "All E2E tests except the active one should remain disabled with @pytest.mark.skip or similar"
  },
  "task_specification": {
    "name": "Implement Basic CombatRenderer (Plain Text)",
    "description": "Create CombatRenderer for formatting combat output (no colors/emoji yet).\n\nFile: modules/infrastructure/cli/combat_renderer.py\n\nImplementation:\n```python\nfrom modules.domain.model.combat_result import CombatResult\nfrom modules.infrastructure.cli.console_output import ConsoleOutput\nfrom modules.infrastructure.cli.config import CLIConfig\n\nclass CombatRenderer:\n    \"\"\"Formats combat events for display.\"\"\"\n\n    def __init__(self, console: ConsoleOutput, config: CLIConfig):\n        self._console = console\n        self._config = config\n\n    def render_combat(self, result: CombatResult) -> None:\n        \"\"\"Render complete combat (plain text for baseline).\"\"\"\n        self._render_initiative(result.initiative_result)\n\n        for round_result in result.rounds:\n            self._render_round(round_result)\n\n        self._render_victory(result)\n\n    def _render_initiative(self, init_result) -> None:\n        \"\"\"Display initiative resolution.\"\"\"\n        self._console.print(\"Rolling Initiative...\")\n        self._console.print(f\"{init_result.attacker.name}: {init_result.attacker_total}\")\n        self._console.print(f\"{init_result.defender.name}: {init_result.defender_total}\")\n        self._console.print(f\"{init_result.attacker.name} attacks first!\")\n        self._console.display_with_delay(\"\", self._config.initiative_winner_delay)\n\n    def _render_round(self, round_result) -> None:\n        \"\"\"Display single combat round.\"\"\"\n        self._console.print(f\"\\n=== ROUND {round_result.round_number} ===\")\n        self._console.display_with_delay(\"\", self._config.round_header_delay)\n\n        # Attacker action\n        action = round_result.attacker_action\n        self._console.print(f\"{action.attacker_name} attacks!\")\n        self._console.print(f\"  Damage: {action.total_damage}\")\n        self._console.print(f\"  {action.defender_name}: {action.defender_old_hp} HP -> {action.defender_new_hp} HP\")\n        self._console.display_with_delay(\"\", self._config.attack_delay)\n\n        # Defender counter-attack (if alive)\n        if round_result.defender_action:\n            action = round_result.defender_action\n            self._console.print(f\"{action.attacker_name} counter-attacks!\")\n            self._console.print(f\"  Damage: {action.total_damage}\")\n            self._console.print(f\"  {action.defender_name}: {action.defender_old_hp} HP -> {action.defender_new_hp} HP\")\n            self._console.display_with_delay(\"\", self._config.attack_delay)\n        else:\n            self._console.print(f\"{round_result.attacker_action.defender_name} has been defeated!\")\n            self._console.display_with_delay(\"\", self._config.death_delay)\n\n    def _render_victory(self, result: CombatResult) -> None:\n        \"\"\"Display victory announcement.\"\"\"\n        self._console.print(f\"\\n=== {result.winner.name.upper()} WINS! ===\")\n        self._console.print(f\"Combat lasted {result.total_rounds} rounds\")\n        self._console.print(f\"{result.winner.name}: {result.winner.hp} HP remaining\")\n        self._console.print(f\"{result.loser.name}: 0 HP (defeated)\")\n        self._console.prompt_continue(\"\\nPress ENTER to exit...\")\n```\n\nUnit tests:\n- File: tests/unit/infrastructure/cli/test_combat_renderer.py\n- Test: test_render_initiative_displays_rolls()\n- Test: test_render_round_displays_attacker_action()\n- Test: test_render_round_displays_counter_if_alive()\n- Test: test_render_round_no_counter_if_defender_dead()\n- Test: test_render_victory_displays_winner()\n\nTest pattern (using test_mode for zero delays):\n```python\ndef test_render_initiative_displays_rolls():\n    mock_console = Mock(spec=ConsoleOutput)\n    config = CLIConfig.test_mode()\n    renderer = CombatRenderer(mock_console, config)\n\n    # Create InitiativeResult with known values\n    char1 = Character(\"Hero\", 50, 10)\n    char2 = Character(\"Villain\", 40, 8)\n    init_result = InitiativeResult(\n        attacker=char1, defender=char2,\n        attacker_roll=5, defender_roll=3,\n        attacker_total=65, defender_total=51\n    )\n\n    renderer._render_initiative(init_result)\n\n    # Verify output contains expected text\n    calls = [str(call) for call in mock_console.print.call_args_list]\n    assert any(\"Hero\" in str(call) for call in calls)\n    assert any(\"attacks first\" in str(call) for call in calls)\n\n    # PHASE 3: After emoji implementation, add emoji/fallback verification\n    # Example: assert any('\u2694\ufe0f' in str(call) or '[ATK]' in str(call) for call in calls)\n    # This validates emoji integration end-to-end (emoji OR fallback present)\n```\n\nValidation:\n- pytest tests/unit/infrastructure/cli/test_combat_renderer.py -v\n- All unit tests PASS (5 tests minimum)\n- Code coverage > 85%\n",
    "motivation": "CombatRenderer is the heart of combat visualization. Plain text implementation proves\nrendering logic works before adding visual complexity (emoji, colors). Testable in isolation.\n",
    "detailed_instructions": "Create CombatRenderer for formatting combat output (no colors/emoji yet).\n\nFile: modules/infrastructure/cli/combat_renderer.py\n\nImplementation:\n```python\nfrom modules.domain.model.combat_result import CombatResult\nfrom modules.infrastructure.cli.console_output import ConsoleOutput\nfrom modules.infrastructure.cli.config import CLIConfig\n\nclass CombatRenderer:\n    \"\"\"Formats combat events for display.\"\"\"\n\n    def __init__(self, console: ConsoleOutput, config: CLIConfig):\n        self._console = console\n        self._config = config\n\n    def render_combat(self, result: CombatResult) -> None:\n        \"\"\"Render complete combat (plain text for baseline).\"\"\"\n        self._render_initiative(result.initiative_result)\n\n        for round_result in result.rounds:\n            self._render_round(round_result)\n\n        self._render_victory(result)\n\n    def _render_initiative(self, init_result) -> None:\n        \"\"\"Display initiative resolution.\"\"\"\n        self._console.print(\"Rolling Initiative...\")\n        self._console.print(f\"{init_result.attacker.name}: {init_result.attacker_total}\")\n        self._console.print(f\"{init_result.defender.name}: {init_result.defender_total}\")\n        self._console.print(f\"{init_result.attacker.name} attacks first!\")\n        self._console.display_with_delay(\"\", self._config.initiative_winner_delay)\n\n    def _render_round(self, round_result) -> None:\n        \"\"\"Display single combat round.\"\"\"\n        self._console.print(f\"\\n=== ROUND {round_result.round_number} ===\")\n        self._console.display_with_delay(\"\", self._config.round_header_delay)\n\n        # Attacker action\n        action = round_result.attacker_action\n        self._console.print(f\"{action.attacker_name} attacks!\")\n        self._console.print(f\"  Damage: {action.total_damage}\")\n        self._console.print(f\"  {action.defender_name}: {action.defender_old_hp} HP -> {action.defender_new_hp} HP\")\n        self._console.display_with_delay(\"\", self._config.attack_delay)\n\n        # Defender counter-attack (if alive)\n        if round_result.defender_action:\n            action = round_result.defender_action\n            self._console.print(f\"{action.attacker_name} counter-attacks!\")\n            self._console.print(f\"  Damage: {action.total_damage}\")\n            self._console.print(f\"  {action.defender_name}: {action.defender_old_hp} HP -> {action.defender_new_hp} HP\")\n            self._console.display_with_delay(\"\", self._config.attack_delay)\n        else:\n            self._console.print(f\"{round_result.attacker_action.defender_name} has been defeated!\")\n            self._console.display_with_delay(\"\", self._config.death_delay)\n\n    def _render_victory(self, result: CombatResult) -> None:\n        \"\"\"Display victory announcement.\"\"\"\n        self._console.print(f\"\\n=== {result.winner.name.upper()} WINS! ===\")\n        self._console.print(f\"Combat lasted {result.total_rounds} rounds\")\n        self._console.print(f\"{result.winner.name}: {result.winner.hp} HP remaining\")\n        self._console.print(f\"{result.loser.name}: 0 HP (defeated)\")\n        self._console.prompt_continue(\"\\nPress ENTER to exit...\")\n```\n\nUnit tests:\n- File: tests/unit/infrastructure/cli/test_combat_renderer.py\n- Test: test_render_initiative_displays_rolls()\n- Test: test_render_round_displays_attacker_action()\n- Test: test_render_round_displays_counter_if_alive()\n- Test: test_render_round_no_counter_if_defender_dead()\n- Test: test_render_victory_displays_winner()\n\nTest pattern (using test_mode for zero delays):\n```python\ndef test_render_initiative_displays_rolls():\n    mock_console = Mock(spec=ConsoleOutput)\n    config = CLIConfig.test_mode()\n    renderer = CombatRenderer(mock_console, config)\n\n    # Create InitiativeResult with known values\n    char1 = Character(\"Hero\", 50, 10)\n    char2 = Character(\"Villain\", 40, 8)\n    init_result = InitiativeResult(\n        attacker=char1, defender=char2,\n        attacker_roll=5, defender_roll=3,\n        attacker_total=65, defender_total=51\n    )\n\n    renderer._render_initiative(init_result)\n\n    # Verify output contains expected text\n    calls = [str(call) for call in mock_console.print.call_args_list]\n    assert any(\"Hero\" in str(call) for call in calls)\n    assert any(\"attacks first\" in str(call) for call in calls)\n\n    # PHASE 3: After emoji implementation, add emoji/fallback verification\n    # Example: assert any('\u2694\ufe0f' in str(call) or '[ATK]' in str(call) for call in calls)\n    # This validates emoji integration end-to-end (emoji OR fallback present)\n```\n\nValidation:\n- pytest tests/unit/infrastructure/cli/test_combat_renderer.py -v\n- All unit tests PASS (5 tests minimum)\n- Code coverage > 85%\n",
    "acceptance_criteria": [
      "CombatRenderer class exists",
      "render_combat() orchestrates full visualization",
      "_render_initiative() displays rolls and winner",
      "_render_round() displays attacker and defender actions",
      "_render_victory() displays winner and stats",
      "Conditional logic: counter-attack only if defender alive",
      "Unit tests pass (5 tests minimum)",
      "Code coverage > 85%"
    ],
    "estimated_hours": 2.0
  },
  "dependencies": {
    "requires": [
      "01-03"
    ],
    "blocking": [
      "01-05"
    ]
  },
  "state": {
    "status": "DONE",
    "assigned_to": "software-crafter",
    "started_at": "2026-01-10T13:00:00.000000+00:00",
    "completed_at": "2026-01-10T13:15:00.000000+00:00",
    "updated": "2026-01-10T13:15:00.000000+00:00"
  },
  "execution_result": {
    "files_created": [
      "modules/infrastructure/cli/combat_renderer.py",
      "tests/unit/infrastructure/cli/test_combat_renderer.py"
    ],
    "tests_created": 6,
    "tests_passed": 6,
    "code_coverage": "100%",
    "acceptance_criteria_met": [
      "CombatRenderer class exists",
      "render_combat() orchestrates full visualization",
      "_render_initiative() displays rolls and winner",
      "_render_round() displays attacker and defender actions",
      "_render_victory() displays winner and stats",
      "Conditional logic: counter-attack only if defender alive",
      "Unit tests pass (6 tests, all passing)",
      "Code coverage > 85% (100% achieved)"
    ],
    "validation_output": "pytest tests/unit/infrastructure/cli/test_combat_renderer.py -v: 6 passed in 0.24s\npytest tests/unit/ -v: 39 passed in 0.32s\nCoverage: 100%",
    "notes": "Successfully implemented CombatRenderer with plain text rendering for baseline CLI. All tests pass with 100% code coverage. Ready for integration with main CLI entry point."
  }
}
